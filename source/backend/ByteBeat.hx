package backend;

import haxe.io.Bytes;
import haxe.io.BytesOutput;
import openfl.media.Sound;

class ByteBeat {
    /**
     * Number of audio channels (1 = mono, 2 = stereo).
     */
    public var channels:Int;
    /**
     * The number of samples per second (default is 8000 Hz).
     */
    public var sampleRate:Int;
    /**
     * Bit depth of each sample (default is 8-bit).
     */
    public var bitsPerSample:Int;

    public var chunkSize:Int = 0;

    /**
     * Computed byte rate based on sample rate, channels, and bit depth.
     */
    public var byteRate(get, never):Int;
    @:noCompletion function get_byteRate():Int {
        return Std.int(sampleRate * channels * bitsPerSample / 8);
    }

    /**
     * Computed block alignment for audio format.
     */
    public var blockAlign(get, never):Int;
    @:noCompletion function get_blockAlign():Int {
        return Std.int(channels * bitsPerSample / 8);
    }

    /**
     * Computed length of the audio data in seconds.
     */
    public var length(get, never):Float;
    @:noCompletion function get_length():Float {
        var numSamples:Float = totalSize / (bitsPerSample / 8 * channels);
        return numSamples / sampleRate;
    }

    public var totalSize:Int;
    var output:BytesOutput;

    /**
     * Constructor to initialize audio properties.
     * @param channels Number of audio channels (1 or 2).
     * @param sampleRate Sample rate in Hz.
     * @param bitsPerSample Bit depth per sample.
     */
    public function new(?channels:Int = 1, ?sampleRate:Int = 8000, ?bitsPerSample:Int = 8) {
        this.channels = channels;
        this.sampleRate = sampleRate;
        this.bitsPerSample = bitsPerSample;
    }

    /**
     * Generates a bytebeat-style WAV audio file.
     * @param secs Number of audio length.
     * @param formula returns function of bytebeat formula.
     * @return Generated bytebeat.
     */
    public function make(secs:Int, formula:(i:Int) -> Int):Bytes {
        output = new BytesOutput();

        // Write RIFF header
        output.writeString("RIFF");
        output.writeInt32(chunkSize); // Placeholder for chunk size
        output.writeString("WAVEfmt "); // Write fmt chunk
        output.writeInt32(16); // Chunk size
        output.writeInt16(1); // Audio format (PCM)

        output.writeInt16(channels);
        output.writeInt32(sampleRate);
        output.writeInt32(byteRate); // Byte rate
        output.writeInt16(blockAlign); // Block align
        output.writeInt16(bitsPerSample);

        // Write data chunk
        output.writeString("data");

        var data:Bytes = Bytes.alloc(sampleRate * secs);
        for (t in 0...data.length) data.set(t, Std.int(formula(t)) & 0xFF);

        output.writeInt32(data.length * channels * Std.int(bitsPerSample / 8));
        output.writeBytes(data, 0, data.length);

        // Update chunk size
        totalSize = output.length;
        var bytes:Bytes = output.getBytes();
        bytes.setInt32(4, totalSize - 8);

        return bytes;
    }

    /**
     * Convert byte data into a playable sound.
     *
     * @param input The byte data.
     * @return The playable sound, or `null` if loading failed.
     */
    public function buildSoundFromBytes(input:Null<Bytes>):Null<FlxSound> {
        if (input == null) return null;

        var tmpSound:Sound = new Sound();
        tmpSound.loadCompressedDataFromByteArray(openfl.utils.ByteArray.fromBytes(input), input.length);
        return new FlxSound().loadEmbedded(tmpSound);
    }

    /**
     * Cleans up memory by closing the `BytesOutput` stream and setting it to `null`.
    */
    public function dispose():Void {
        output.close();
        output = null;
    }

    public function toString():String {
        return '(Channels: $channels | SampleRate: $sampleRate | BitsPerSample: $bitsPerSample | Length: $length)';
    }
}